{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "9951e1e1",
   "metadata": {
    "papermill": {
     "duration": 0.008267,
     "end_time": "2024-08-14T17:27:20.982102",
     "exception": false,
     "start_time": "2024-08-14T17:27:20.973835",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Importing Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "342be04b",
   "metadata": {
    "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
    "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:21.000137Z",
     "iopub.status.busy": "2024-08-14T17:27:20.999740Z",
     "iopub.status.idle": "2024-08-14T17:27:21.010560Z",
     "shell.execute_reply": "2024-08-14T17:27:21.009522Z"
    },
    "papermill": {
     "duration": 0.022633,
     "end_time": "2024-08-14T17:27:21.013142",
     "exception": false,
     "start_time": "2024-08-14T17:27:20.990509",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import os"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "f2e00639",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:21.030757Z",
     "iopub.status.busy": "2024-08-14T17:27:21.030226Z",
     "iopub.status.idle": "2024-08-14T17:27:21.036533Z",
     "shell.execute_reply": "2024-08-14T17:27:21.035474Z"
    },
    "papermill": {
     "duration": 0.017901,
     "end_time": "2024-08-14T17:27:21.039019",
     "exception": false,
     "start_time": "2024-08-14T17:27:21.021118",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def extract():\n",
    "    text = ''\n",
    "    path = '/kaggle/input/marvel-cinematic-universe-dialogue-dataset'\n",
    "    for file in os.listdir(path):\n",
    "        path_file = os.path.join(path + '/', file)\n",
    "        with open(path_file, 'r', errors= 'ignore') as f:\n",
    "            text += f.read()\n",
    "    return text"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "48a8c2d1",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:21.056890Z",
     "iopub.status.busy": "2024-08-14T17:27:21.056474Z",
     "iopub.status.idle": "2024-08-14T17:27:21.243080Z",
     "shell.execute_reply": "2024-08-14T17:27:21.241921Z"
    },
    "papermill": {
     "duration": 0.199003,
     "end_time": "2024-08-14T17:27:21.246273",
     "exception": false,
     "start_time": "2024-08-14T17:27:21.047270",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "text = extract()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "ec8320ea",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:21.266445Z",
     "iopub.status.busy": "2024-08-14T17:27:21.265524Z",
     "iopub.status.idle": "2024-08-14T17:27:21.273401Z",
     "shell.execute_reply": "2024-08-14T17:27:21.272384Z"
    },
    "papermill": {
     "duration": 0.019763,
     "end_time": "2024-08-14T17:27:21.275643",
     "exception": false,
     "start_time": "2024-08-14T17:27:21.255880",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'(BUCKY SCREAMING)\\n(CONTINUES SCREAMING)\\n- (KARPOV SPEAKING RUSSIAN) - (PANTING)\\nLonging\\nRusted\\nSeven'"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "text[:100]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ad691682",
   "metadata": {
    "papermill": {
     "duration": 0.00783,
     "end_time": "2024-08-14T17:27:21.291600",
     "exception": false,
     "start_time": "2024-08-14T17:27:21.283770",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Text Processing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "1b7b0cbf",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:21.309375Z",
     "iopub.status.busy": "2024-08-14T17:27:21.308634Z",
     "iopub.status.idle": "2024-08-14T17:27:21.316456Z",
     "shell.execute_reply": "2024-08-14T17:27:21.315325Z"
    },
    "papermill": {
     "duration": 0.019341,
     "end_time": "2024-08-14T17:27:21.318791",
     "exception": false,
     "start_time": "2024-08-14T17:27:21.299450",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "class Preprocess():\n",
    "    def __init__(self, text):\n",
    "        super().__init__()\n",
    "        self.text = text\n",
    "        \n",
    "    def create_vocab(self):\n",
    "        vocab = sorted(list(set(self.text)))\n",
    "        self.stoi = {s: i for i, s in enumerate(vocab)}\n",
    "        self.itos = {i: s for s, i in self.stoi.items()}\n",
    "        return vocab, len(vocab), self.stoi, self.itos\n",
    "    \n",
    "    def encode(self, string):\n",
    "        return [self.stoi[char] for char in string]\n",
    "    \n",
    "    def decode(self, array):\n",
    "        return ''.join(self.itos[idx] for idx in array)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "edb8b745",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:21.340019Z",
     "iopub.status.busy": "2024-08-14T17:27:21.339452Z",
     "iopub.status.idle": "2024-08-14T17:27:21.366991Z",
     "shell.execute_reply": "2024-08-14T17:27:21.365828Z"
    },
    "papermill": {
     "duration": 0.042517,
     "end_time": "2024-08-14T17:27:21.369333",
     "exception": false,
     "start_time": "2024-08-14T17:27:21.326816",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "text_processor = Preprocess(text)\n",
    "vocab, vocab_size, stoi, itos = text_processor.create_vocab()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "bd1666d7",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:21.387511Z",
     "iopub.status.busy": "2024-08-14T17:27:21.387104Z",
     "iopub.status.idle": "2024-08-14T17:27:21.395424Z",
     "shell.execute_reply": "2024-08-14T17:27:21.394164Z"
    },
    "papermill": {
     "duration": 0.02071,
     "end_time": "2024-08-14T17:27:21.398069",
     "exception": false,
     "start_time": "2024-08-14T17:27:21.377359",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[61, 58, 65, 65, 68]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "'hello'"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "print(text_processor.encode('hello'))\n",
    "text_processor.decode(text_processor.encode('hello'))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "497fe06c",
   "metadata": {
    "papermill": {
     "duration": 0.00794,
     "end_time": "2024-08-14T17:27:21.414510",
     "exception": false,
     "start_time": "2024-08-14T17:27:21.406570",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Set Device"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "477879f9",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:21.432711Z",
     "iopub.status.busy": "2024-08-14T17:27:21.432297Z",
     "iopub.status.idle": "2024-08-14T17:27:25.011014Z",
     "shell.execute_reply": "2024-08-14T17:27:25.009681Z"
    },
    "papermill": {
     "duration": 3.591026,
     "end_time": "2024-08-14T17:27:25.013811",
     "exception": false,
     "start_time": "2024-08-14T17:27:21.422785",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import torch"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "6623a3e3",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:25.032726Z",
     "iopub.status.busy": "2024-08-14T17:27:25.031830Z",
     "iopub.status.idle": "2024-08-14T17:27:25.039034Z",
     "shell.execute_reply": "2024-08-14T17:27:25.037863Z"
    },
    "papermill": {
     "duration": 0.019081,
     "end_time": "2024-08-14T17:27:25.041218",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.022137",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'cpu'"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "device = 'cuda' if torch.cuda.is_available() else 'cpu'\n",
    "device"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "db4f3e25",
   "metadata": {
    "papermill": {
     "duration": 0.007836,
     "end_time": "2024-08-14T17:27:25.057475",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.049639",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Split Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "b6d6c55f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:25.075566Z",
     "iopub.status.busy": "2024-08-14T17:27:25.075111Z",
     "iopub.status.idle": "2024-08-14T17:27:25.080041Z",
     "shell.execute_reply": "2024-08-14T17:27:25.078949Z"
    },
    "papermill": {
     "duration": 0.016758,
     "end_time": "2024-08-14T17:27:25.082479",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.065721",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import torch.nn as nn"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "d54f39ac",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:25.101578Z",
     "iopub.status.busy": "2024-08-14T17:27:25.100239Z",
     "iopub.status.idle": "2024-08-14T17:27:25.418637Z",
     "shell.execute_reply": "2024-08-14T17:27:25.417519Z"
    },
    "papermill": {
     "duration": 0.330326,
     "end_time": "2024-08-14T17:27:25.421127",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.090801",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(tensor([ 8, 29, 48, 30, 38, 52,  1, 46, 30, 45, 32, 28, 40, 36, 41, 34,  9,  0,\n",
       "          8, 30, 42, 41, 47, 36, 41, 48, 32, 46,  1, 46, 30, 45, 32, 28, 40, 36,\n",
       "         41, 34,  9,  0, 12,  1,  8, 38, 28, 45, 43, 42, 49,  1]),\n",
       " 1147310)"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "data = torch.tensor(text_processor.encode(text), dtype = torch.long)\n",
    "data[:50], len(data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "79e59465",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:25.439634Z",
     "iopub.status.busy": "2024-08-14T17:27:25.439212Z",
     "iopub.status.idle": "2024-08-14T17:27:25.447908Z",
     "shell.execute_reply": "2024-08-14T17:27:25.446750Z"
    },
    "papermill": {
     "duration": 0.02065,
     "end_time": "2024-08-14T17:27:25.450347",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.429697",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(917848, 229462)"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "n = int(0.8 * len(data))\n",
    "train = data[:n]\n",
    "val = data[n:]\n",
    "len(train), len(val)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "c2cd859a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:25.469193Z",
     "iopub.status.busy": "2024-08-14T17:27:25.468810Z",
     "iopub.status.idle": "2024-08-14T17:27:25.475757Z",
     "shell.execute_reply": "2024-08-14T17:27:25.474683Z"
    },
    "papermill": {
     "duration": 0.018985,
     "end_time": "2024-08-14T17:27:25.478070",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.459085",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def split(type):\n",
    "    data = train if type == 'train' else val\n",
    "    idx = torch.randint(len(data) - block_size, (batch_size, ))\n",
    "    X = torch.stack([data[i: i + block_size] for i in idx])\n",
    "    y = torch.stack([data[i + 1: i + block_size + 1] for i in idx])\n",
    "    X, y = X.to(device), y.to(device)\n",
    "    return X, y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "a15dbf86",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:25.497188Z",
     "iopub.status.busy": "2024-08-14T17:27:25.496282Z",
     "iopub.status.idle": "2024-08-14T17:27:25.501905Z",
     "shell.execute_reply": "2024-08-14T17:27:25.500882Z"
    },
    "papermill": {
     "duration": 0.017628,
     "end_time": "2024-08-14T17:27:25.504158",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.486530",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "batch_size = 1 \n",
    "block_size = 32\n",
    "max_iters = 1\n",
    "eval_interval = 500\n",
    "learning_rate = 1e-3\n",
    "eval_iters = 250\n",
    "n_embd = 384\n",
    "n_head = 6\n",
    "n_layer = 6\n",
    "dropout = 0.2\n",
    "window_size = 128\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "d70cf702",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:25.522761Z",
     "iopub.status.busy": "2024-08-14T17:27:25.522310Z",
     "iopub.status.idle": "2024-08-14T17:27:25.556022Z",
     "shell.execute_reply": "2024-08-14T17:27:25.554990Z"
    },
    "papermill": {
     "duration": 0.045494,
     "end_time": "2024-08-14T17:27:25.558250",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.512756",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(torch.Size([1, 32]), torch.Size([1, 32]))"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Xtr, ytr = split('train')\n",
    "Xtr.shape, ytr.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fe60e71e",
   "metadata": {
    "papermill": {
     "duration": 0.008065,
     "end_time": "2024-08-14T17:27:25.574992",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.566927",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Define Error List"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "ab04491a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:25.594202Z",
     "iopub.status.busy": "2024-08-14T17:27:25.593465Z",
     "iopub.status.idle": "2024-08-14T17:27:25.598661Z",
     "shell.execute_reply": "2024-08-14T17:27:25.597495Z"
    },
    "papermill": {
     "duration": 0.017463,
     "end_time": "2024-08-14T17:27:25.601126",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.583663",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import torch.nn.functional as F"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "c41b9ff7",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:25.621118Z",
     "iopub.status.busy": "2024-08-14T17:27:25.620247Z",
     "iopub.status.idle": "2024-08-14T17:27:25.627067Z",
     "shell.execute_reply": "2024-08-14T17:27:25.625875Z"
    },
    "papermill": {
     "duration": 0.019205,
     "end_time": "2024-08-14T17:27:25.629253",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.610048",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "@torch.no_grad()\n",
    "def estimate_loss():\n",
    "    out = {}\n",
    "    model.eval()\n",
    "    for splits in ['train', 'val']:\n",
    "        losses = torch.zeros(eval_iters)\n",
    "        for k in range(eval_iters):\n",
    "            X, Y = split(splits)\n",
    "            logits, loss = model(X, Y)\n",
    "            losses[k] = loss.item()\n",
    "        out[splits] = losses.mean()\n",
    "    model.train()\n",
    "    return out"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "367f9e73",
   "metadata": {
    "papermill": {
     "duration": 0.008339,
     "end_time": "2024-08-14T17:27:25.646339",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.638000",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Create Model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "3e735e22",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:25.665613Z",
     "iopub.status.busy": "2024-08-14T17:27:25.665198Z",
     "iopub.status.idle": "2024-08-14T17:27:25.678684Z",
     "shell.execute_reply": "2024-08-14T17:27:25.677503Z"
    },
    "papermill": {
     "duration": 0.026323,
     "end_time": "2024-08-14T17:27:25.681441",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.655118",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "class LongformerAttention(nn.Module):\n",
    "    def __init__(self, head_size, window_size):\n",
    "        super().__init__()\n",
    "        self.key = nn.Linear(n_embd, head_size, bias=False)\n",
    "        self.query = nn.Linear(n_embd, head_size, bias=False)\n",
    "        self.value = nn.Linear(n_embd, head_size, bias=False)\n",
    "        self.window_size = window_size\n",
    "        self.dropout = nn.Dropout(dropout)\n",
    "\n",
    "    def forward(self, x):\n",
    "        B, T, C = x.shape\n",
    "        k = self.key(x)\n",
    "        q = self.query(x)\n",
    "        v = self.value(x)\n",
    "\n",
    "        attention_scores = q @ k.transpose(-2, -1) * C**-0.5\n",
    "        attention_scores = self._mask_local_attention(attention_scores)\n",
    "        attention_probs = F.softmax(attention_scores, dim=-1)\n",
    "        attention_probs = self.dropout(attention_probs)\n",
    "        local_out = attention_probs @ v\n",
    "\n",
    "        # Debugging Prints\n",
    "#         print(f\"attention_scores: {attention_scores.mean()}, min: {attention_scores.min()}, max: {attention_scores.max()}\")\n",
    "#         print(f\"attention_probs: {attention_probs.mean()}, min: {attention_probs.min()}, max: {attention_probs.max()}\")\n",
    "#         print(f\"local_out: {local_out.mean()}, min: {local_out.min()}, max: {local_out.max()}\")\n",
    "\n",
    "        return local_out\n",
    "\n",
    "    def _mask_local_attention(self, attention_scores):\n",
    "        B, T, _ = attention_scores.size()\n",
    "        mask = torch.zeros(B, T, T, device=attention_scores.device)\n",
    "\n",
    "        for i in range(T):\n",
    "            start = max(0, i - self.window_size)\n",
    "            end = min(T, i + self.window_size + 1)\n",
    "            mask[:, start:end, i] = 1\n",
    "        attention_scores = attention_scores.masked_fill(mask == 0, float('-inf'))\n",
    "#         print(f\"mask: {mask.mean()}, min: {mask.min()}, max: {mask.max()}\")\n",
    "#         print(f\"masked_attention_scores: {attention_scores.mean()}, min: {attention_scores.min()}, max: {attention_scores.max()}\")\n",
    "\n",
    "        return attention_scores\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "65685c11",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:25.700823Z",
     "iopub.status.busy": "2024-08-14T17:27:25.700399Z",
     "iopub.status.idle": "2024-08-14T17:27:25.707730Z",
     "shell.execute_reply": "2024-08-14T17:27:25.706562Z"
    },
    "papermill": {
     "duration": 0.019499,
     "end_time": "2024-08-14T17:27:25.710034",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.690535",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "class MultiHeadLongformerAttention(nn.Module):\n",
    "    def __init__(self, num_heads, head_size, window_size):\n",
    "        super().__init__()\n",
    "        self.heads = nn.ModuleList(\n",
    "            [LongformerAttention(head_size, window_size) for _ in range(num_heads)]\n",
    "        )\n",
    "        self.proj = nn.Linear(n_embd, n_embd)\n",
    "        self.dropout = nn.Dropout(dropout)\n",
    "\n",
    "    def forward(self, x):\n",
    "        out = torch.cat([h(x) for h in self.heads], dim=-1)\n",
    "        out = self.dropout(self.proj(out))\n",
    "        return out\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "0cbc3499",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:25.729099Z",
     "iopub.status.busy": "2024-08-14T17:27:25.728541Z",
     "iopub.status.idle": "2024-08-14T17:27:25.735363Z",
     "shell.execute_reply": "2024-08-14T17:27:25.734054Z"
    },
    "papermill": {
     "duration": 0.01904,
     "end_time": "2024-08-14T17:27:25.737791",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.718751",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "class FeedFoward(nn.Module):\n",
    "    def __init__(self, n_embd):\n",
    "        super().__init__()\n",
    "        self.net = nn.Sequential(\n",
    "            nn.Linear(n_embd, 4 * n_embd),\n",
    "            nn.ReLU(),\n",
    "            nn.Linear(4 * n_embd, n_embd),\n",
    "            nn.Dropout(dropout),\n",
    "        )\n",
    "\n",
    "    def forward(self, x):\n",
    "        return self.net(x)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "967e0cbb",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:25.757172Z",
     "iopub.status.busy": "2024-08-14T17:27:25.756785Z",
     "iopub.status.idle": "2024-08-14T17:27:25.763802Z",
     "shell.execute_reply": "2024-08-14T17:27:25.762841Z"
    },
    "papermill": {
     "duration": 0.019149,
     "end_time": "2024-08-14T17:27:25.766084",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.746935",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "class Block(nn.Module):\n",
    "    def __init__(self, n_embd, n_head, window_size):\n",
    "        super().__init__()\n",
    "        head_size = n_embd // n_head\n",
    "        self.sa = MultiHeadLongformerAttention(n_head, head_size, window_size)\n",
    "        self.ffwd = FeedFoward(n_embd)\n",
    "        self.ln1 = nn.LayerNorm(n_embd)\n",
    "        self.ln2 = nn.LayerNorm(n_embd)\n",
    "\n",
    "    def forward(self, x):\n",
    "        x = x + self.sa(self.ln1(x))\n",
    "        x = x + self.ffwd(self.ln2(x))\n",
    "        return x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "dc36b628",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:25.784938Z",
     "iopub.status.busy": "2024-08-14T17:27:25.784561Z",
     "iopub.status.idle": "2024-08-14T17:27:25.798356Z",
     "shell.execute_reply": "2024-08-14T17:27:25.797132Z"
    },
    "papermill": {
     "duration": 0.025886,
     "end_time": "2024-08-14T17:27:25.800605",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.774719",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "class BigramLanguageModel(nn.Module):\n",
    "    def __init__(self):\n",
    "        super().__init__()\n",
    "        self.token_embedding_table = nn.Embedding(vocab_size, n_embd)\n",
    "        self.position_embedding_table = nn.Embedding(block_size, n_embd)\n",
    "        self.blocks = nn.Sequential(\n",
    "            *[Block(n_embd, n_head=n_head, window_size=window_size)\n",
    "              for _ in range(n_layer)]\n",
    "        )\n",
    "        self.ln_f = nn.LayerNorm(n_embd)\n",
    "        self.lm_head = nn.Linear(n_embd, vocab_size)\n",
    "\n",
    "    def forward(self, idx, targets=None):\n",
    "        B, T = idx.shape\n",
    "#         print(B,T)\n",
    "        tok_emb = self.token_embedding_table(idx)\n",
    "#         print(tok_emb)\n",
    "        pos_emb = self.position_embedding_table(torch.arange(T, device=device))\n",
    "#         print(pos_emb)\n",
    "        x = tok_emb + pos_emb\n",
    "        x = self.blocks(x)\n",
    "        x = self.ln_f(x)\n",
    "        logits = self.lm_head(x)\n",
    "\n",
    "        # Debugging Prints\n",
    "#         print(f\"tok_emb: {tok_emb.mean()}, min: {tok_emb.min()}, max: {tok_emb.max()}\")\n",
    "#         print(f\"pos_emb: {pos_emb.mean()}, min: {pos_emb.min()}, max: {pos_emb.max()}\")\n",
    "#         print(f\"x after blocks: {x.mean()}, min: {x.min()}, max: {x.max()}\")\n",
    "#         print(f\"logits: {logits.mean()}, min: {logits.min()}, max: {logits.max()}\")\n",
    "\n",
    "        if targets is None:\n",
    "            loss = None\n",
    "        else:\n",
    "            B, T, C = logits.shape\n",
    "            logits = logits.view(B*T, C)\n",
    "            targets = targets.view(B*T)\n",
    "            loss = F.cross_entropy(logits, targets)\n",
    "\n",
    "        return logits, loss\n",
    "    \n",
    "    def generate(self, idx, max_new_tokens):\n",
    "        for _ in range(max_new_tokens):\n",
    "            print(idx)\n",
    "            logits, _ = self(idx)  # Get logits and ignore loss\n",
    "            \n",
    "            if torch.isnan(logits).any() or torch.isinf(logits).any():\n",
    "                print(f\"NaNs or Infs detected in logits: {logits}\")\n",
    "                raise ValueError(\"Logits contain NaNs or Infs\")\n",
    "\n",
    "            logits = logits[:, -1, :]  # becomes (B, C)\n",
    "            probs = F.softmax(logits, dim=-1)  # (B, C)\n",
    "\n",
    "            if torch.isnan(probs).any() or torch.isinf(probs).any():\n",
    "                print(f\"NaNs or Infs detected in probs: {probs}\")\n",
    "                raise ValueError(\"Probabilities contain NaNs or Infs\")\n",
    "\n",
    "            idx_next = torch.multinomial(probs, num_samples=1)  # (B, 1)\n",
    "            idx = torch.cat((idx, idx_next), dim=1)  # (B, T+1)\n",
    "\n",
    "        return idx"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "0db6a2c0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:25.819339Z",
     "iopub.status.busy": "2024-08-14T17:27:25.818984Z",
     "iopub.status.idle": "2024-08-14T17:27:25.975121Z",
     "shell.execute_reply": "2024-08-14T17:27:25.973948Z"
    },
    "papermill": {
     "duration": 0.16838,
     "end_time": "2024-08-14T17:27:25.977659",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.809279",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "10.717524 M parameters\n"
     ]
    }
   ],
   "source": [
    "model = BigramLanguageModel()\n",
    "m = model.to(device)\n",
    "print(sum(p.numel() for p in m.parameters())/1e6, 'M parameters')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "714d4667",
   "metadata": {
    "papermill": {
     "duration": 0.008575,
     "end_time": "2024-08-14T17:27:25.995271",
     "exception": false,
     "start_time": "2024-08-14T17:27:25.986696",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Train the Model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "466d5f4e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:26.015744Z",
     "iopub.status.busy": "2024-08-14T17:27:26.014446Z",
     "iopub.status.idle": "2024-08-14T17:27:43.430582Z",
     "shell.execute_reply": "2024-08-14T17:27:43.429441Z"
    },
    "papermill": {
     "duration": 17.428555,
     "end_time": "2024-08-14T17:27:43.433329",
     "exception": false,
     "start_time": "2024-08-14T17:27:26.004774",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "step 0: train loss 4.5032, val loss 4.5156\n"
     ]
    }
   ],
   "source": [
    "optimizer = torch.optim.AdamW(model.parameters(), lr=learning_rate)\n",
    "\n",
    "for iter in range(max_iters):\n",
    "    if iter % eval_interval == 0 or iter == max_iters - 1:\n",
    "        losses = estimate_loss()\n",
    "        print(f\"step {iter}: train loss {losses['train']:.4f}, val loss {losses['val']:.4f}\")\n",
    "    xb, yb = split('train')\n",
    "    logits, loss = model(xb, yb)\n",
    "    optimizer.zero_grad(set_to_none=True)\n",
    "    loss.backward()\n",
    "    optimizer.step()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1157e3cd",
   "metadata": {
    "papermill": {
     "duration": 0.008474,
     "end_time": "2024-08-14T17:27:43.450686",
     "exception": false,
     "start_time": "2024-08-14T17:27:43.442212",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Generate Text"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "e978c4c0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:43.469868Z",
     "iopub.status.busy": "2024-08-14T17:27:43.469337Z",
     "iopub.status.idle": "2024-08-14T17:27:43.477740Z",
     "shell.execute_reply": "2024-08-14T17:27:43.476708Z"
    },
    "papermill": {
     "duration": 0.020525,
     "end_time": "2024-08-14T17:27:43.479916",
     "exception": false,
     "start_time": "2024-08-14T17:27:43.459391",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def clamp_indices(indices, vocab_size):\n",
    "    return [min(max(idx, 0), vocab_size - 1) for idx in indices]\n",
    "\n",
    "def generate(num_words):\n",
    "    context = torch.zeros((1, 1), dtype=torch.long, device=device)\n",
    "    print(\"Initial context:\", context)\n",
    "    \n",
    "    generated_indices = []  # Initialize to ensure it's defined\n",
    "\n",
    "    try:\n",
    "        generated_tensor = m.generate(context, max_new_tokens=num_words)\n",
    "        print(\"Generated tensor:\", generated_tensor)\n",
    "        generated_indices = generated_tensor[0].tolist()\n",
    "        \n",
    "        # Clamp indices to be within the valid range\n",
    "        clamped_indices = clamp_indices(generated_indices, vocab_size)\n",
    "        print(\"Clamped indices:\", clamped_indices)\n",
    "    except Exception as e:\n",
    "        print(f\"Error occurred: {e}\")\n",
    "        return  # Exit early if there's an error\n",
    "    \n",
    "    # Decode and print the generated text\n",
    "    try:\n",
    "        decoded_text = text_processor.decode(clamped_indices)\n",
    "        print(\"Decoded text:\", decoded_text)\n",
    "    except Exception as e:\n",
    "        print(f\"Error decoding text: {e}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "c90eb3dd",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:43.499571Z",
     "iopub.status.busy": "2024-08-14T17:27:43.498795Z",
     "iopub.status.idle": "2024-08-14T17:27:43.503830Z",
     "shell.execute_reply": "2024-08-14T17:27:43.502773Z"
    },
    "papermill": {
     "duration": 0.017953,
     "end_time": "2024-08-14T17:27:43.506770",
     "exception": false,
     "start_time": "2024-08-14T17:27:43.488817",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Vocabulary size: 84\n"
     ]
    }
   ],
   "source": [
    "print(f\"Vocabulary size: {vocab_size}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "4d84e5bd",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-08-14T17:27:43.526719Z",
     "iopub.status.busy": "2024-08-14T17:27:43.526199Z",
     "iopub.status.idle": "2024-08-14T17:27:44.535086Z",
     "shell.execute_reply": "2024-08-14T17:27:44.533787Z"
    },
    "papermill": {
     "duration": 1.021993,
     "end_time": "2024-08-14T17:27:44.537629",
     "exception": false,
     "start_time": "2024-08-14T17:27:43.515636",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Initial context: tensor([[0]])\n",
      "tensor([[0]])\n",
      "tensor([[ 0, 67]])\n",
      "tensor([[ 0, 67,  1]])\n",
      "tensor([[ 0, 67,  1, 65]])\n",
      "tensor([[ 0, 67,  1, 65,  1]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10, 10]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10, 10,\n",
      "          1]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10, 10,\n",
      "          1,  1]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10, 10,\n",
      "          1,  1, 81]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10, 10,\n",
      "          1,  1, 81, 65]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10, 10,\n",
      "          1,  1, 81, 65, 68]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10, 10,\n",
      "          1,  1, 81, 65, 68,  1]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10, 10,\n",
      "          1,  1, 81, 65, 68,  1, 50]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10, 10,\n",
      "          1,  1, 81, 65, 68,  1, 50, 30]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10, 10,\n",
      "          1,  1, 81, 65, 68,  1, 50, 30,  1]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10, 10,\n",
      "          1,  1, 81, 65, 68,  1, 50, 30,  1, 62]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10, 10,\n",
      "          1,  1, 81, 65, 68,  1, 50, 30,  1, 62, 58]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10, 10,\n",
      "          1,  1, 81, 65, 68,  1, 50, 30,  1, 62, 58, 75]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10, 10,\n",
      "          1,  1, 81, 65, 68,  1, 50, 30,  1, 62, 58, 75, 43]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10, 10,\n",
      "          1,  1, 81, 65, 68,  1, 50, 30,  1, 62, 58, 75, 43, 65]])\n",
      "tensor([[ 0, 67,  1, 65,  1, 67,  1, 58, 39, 48, 38, 55, 62, 58, 81, 68, 10, 10,\n",
      "          1,  1, 81, 65, 68,  1, 50, 30,  1, 62, 58, 75, 43, 65, 68]])\n",
      "Error occurred: index out of range in self\n"
     ]
    }
   ],
   "source": [
    "generate(2000)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d50a16b3",
   "metadata": {
    "papermill": {
     "duration": 0.009649,
     "end_time": "2024-08-14T17:27:44.557258",
     "exception": false,
     "start_time": "2024-08-14T17:27:44.547609",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "none",
   "dataSources": [
    {
     "datasetId": 683366,
     "sourceId": 1199344,
     "sourceType": "datasetVersion"
    }
   ],
   "isGpuEnabled": false,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.13"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 27.425056,
   "end_time": "2024-08-14T17:27:45.589678",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2024-08-14T17:27:18.164622",
   "version": "2.5.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
